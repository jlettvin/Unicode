# UnicodeThis library contains modules for efficient lexical operations onUnicode strings to supportsimple generation of DSL (Domain Specific Languages).```Node.cpp is an O(1) dictionary for translating Codepoints to Tablenumbers.Tree.cpp is an O(N) dictionary for translating u32strings to Canonical Lists.```## Theory:Dictionary lookup typically incurs a cost ofcalculating the hash followed by disambiguating the hash bucket.Both of these calculations can be expensive.The cost is fixed for hash tables with no collisions.Node and Tree are alternative algorithms for guaranteeinglow fixed cost dictionary operations onsimple Unicode codepoints (Node) and simple Unicode codepoint strings (Tree).### Observations supporting the Node implementation:Codepoints have 21 significant bits.  Observe letter B converted to indices.```'B'0x42                          hexadecimal000000000000001000010         binary000 000 000 000 001 000 010   7 groups of 3  0   0   0   0   1   0   2   indices  A   B   C   D   E   F   G   position labels for explanation```Lookup is performed by dereferencing tables to get new indices.The initial table index is 1 because index 0 is used to flag errors.Suppose we want to associate the letter 'B' with its codepoint.In other words, this lookup will be the identity function lookup(0x42) = 0x42.consider all the table values to be hexadecimal.We start by building a table T with the following contents:B: 0042 = 000000000000001000011 = 000 000 000 000 001 000 011 = 0 0 0 0 1 0 2```T = [ [0000 0000 0000 0000 0000 0000 0000 0000], [0002 0000 0000 0000 0000 0000 0000 0000], [0003 0000 0000 0000 0000 0000 0000 0000], [0004 0000 0000 0000 0000 0000 0000 0000], [0005 0000 0000 0000 0000 0000 0000 0000], [0000 0006 0000 0000 0000 0000 0000 0000], [0007 0000 0000 0000 0000 0000 0000 0000], [0000 0000 0042 0000 0000 0000 0000 0000]]```Illustration of sequential dereferencing.``` T[1][A] yields 2 then T[2][B] yields 3 then T[3][C] yields 4 then T[4][D] yields 5 then T[5][E] yields 6 then T[6][F] yields 7 then T[7][G] yields 42  # The association```If we want to add an association for 'C' the table will look like this:C: 0043 = 000000000000001000011 = 000 000 000 000 001 000 011 = 0 0 0 0 1 0 3```T = [ [0000 0000 0000 0000 0000 0000 0000 0000], [0002 0000 0000 0000 0000 0000 0000 0000], [0003 0000 0000 0000 0000 0000 0000 0000], [0004 0000 0000 0000 0000 0000 0000 0000], [0005 0000 0000 0000 0000 0000 0000 0000], [0000 0006 0000 0000 0000 0000 0000 0000], [0007 0000 0000 0000 0000 0000 0000 0000], [0000 0000 0042 0043 0000 0000 0000 0000]]```If we want to add an association for 'L' the table will look like this.L: 004C = 000000000000001001100 = 000 000 000 000 001 001 100 = 0 0 0 0 1 1 4```T = [ [0000 0000 0000 0000 0000 0000 0000 0000], [0002 0000 0000 0000 0000 0000 0000 0000], [0003 0000 0000 0000 0000 0000 0000 0000], [0004 0000 0000 0000 0000 0000 0000 0000], [0005 0000 0000 0000 0000 0000 0000 0000], [0000 0006 0000 0000 0000 0000 0000 0000], [0007 0008 0000 0000 0000 0000 0000 0000], # <- see the addition of table 8 [0000 0000 0042 0043 0000 0000 0000 0000], [0000 0000 0000 0000 004C 0000 0000 0000]  # <- table 8 has 004C at offset 4]```Now, let's add the Chinese character for mountain U+5C71å±±: 5C71 = 000000101110001110001 = 000 000 101 110 001 110 001 = 0 0 5 6 1 6 1```T = [ [0000 0000 0000 0000 0000 0000 0000 0000], [0002 0000 0000 0000 0000 0000 0000 0000], [0003 0000 0000 0000 0000 0000 0000 0000], [0004 0000 0000 0000 0000 0009 0000 0000], # <- see the addition of table 9 [0005 0000 0000 0000 0000 0000 0000 0000], [0000 0006 0000 0000 0000 0000 0000 0000], [0007 0008 0000 0000 0000 0000 0000 0000], [0000 0000 0042 0043 0000 0000 0000 0000], [0000 0000 0000 0000 004C 0000 0000 0000], [0000 0000 0000 0000 0000 0000 000A 0000], # <- see the addition of table A [0000 000B 0000 0000 0000 0000 0000 0000], # <- see the addition of table B [0000 0000 0000 0000 0000 0000 000C 0000], # <- see the addition of table C [0000 000D 0000 0000 0000 0000 0000 0000], # <- see the addition of table D [0000 5C71 0000 0000 0000 0000 0000 0000]  # <- table D has 5C71 at offset 1]```The code for getting an association for a codepoint is```Q(n) = ((codepoint>>(n*3))&0xf)lookup(codepoint) { return T[T[T[T[T[T[T[1]Q(6)]Q(5)]Q(4)]Q(3)]Q(2)]Q(1)]Q(0) }```* 7 multiplies* 7 shifts* 7 masks* 8 table dereferences* 29 total machine code operations in original iAPX86 8088 instructions* operation count may be less for more recent processors* memory consumption per layer is 32 bytesUsing 3 groups of 7, the operation count drops to 17 andthe memory consumption per layer is 512 bytes.For 7 groups of 3:* Codepoints are intrinsically 21 bits.* 21 is the product 3 * 7.* 3 groups of 7 bits or 7 groups of 3 bits will fit a codepoint perfectly.* a 32 bit internal codepoint or index occupies 4 bytes.* 3 bits supports 8 indices while 7 bits supports 128 indices.* 7 groups of 3 is used because the table layer size is small (32 bytes).* The initial association costs 8 * 32 = 256 bytes.* Subsequent associations in-layer cost 0 additional bytes.* Subsequent associations out-of-layer cost at least one final layer each.* Worst case cost (i.e. 0x10FFF) costs 6 additional layers.## Requirements:* g++ (gnu c++ compiler) supporting the -std=c++11 flag* cpplint* valgrind* doxygen## Build:* make clean; clear; make## Node: an O(1) state transition mechanismNode acts as an O(1) dictionary to translateUnicode Codepoints or Unicode Codepoint classifications into table numbers.This enables rapid state machine operations.## Tree: an O(N) token lookup mechanismTree acts as an O(N) dictionary to identify and/or canonicalizevalid Unicode tokens.It can be used to recognize keywords.It can also be used to identify tokens that are absent from the dictionary.