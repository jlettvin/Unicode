\hypertarget{namespacejlettvin}{}\section{jlettvin Namespace Reference}
\label{namespacejlettvin}\index{jlettvin@{jlettvin}}


$<$ cpplint complains even though existing file is included  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
union \hyperlink{unionjlettvin_1_1invariant32__t}{invariant32\+\_\+t}
\item 
class \hyperlink{classjlettvin_1_1_node}{Node}
\begin{DoxyCompactList}\small\item\em dictionary equivalent interface\+: high performance codepoint lookup. \end{DoxyCompactList}\item 
class \hyperlink{classjlettvin_1_1_tree}{Tree}
\begin{DoxyCompactList}\small\item\em dictionary equivalent interface\+: high performance u32string lookup. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\hypertarget{namespacejlettvin_a7c7cf84f4fd67858c46a1077ed2e3ad4}{}typedef unsigned char \hyperlink{namespacejlettvin_a7c7cf84f4fd67858c46a1077ed2e3ad4}{ubyte\+\_\+t}\label{namespacejlettvin_a7c7cf84f4fd67858c46a1077ed2e3ad4}

\begin{DoxyCompactList}\small\item\em buffer element type \end{DoxyCompactList}\item 
\hypertarget{namespacejlettvin_a5c480560edc7a71c9f5ae6dad14e6fec}{}typedef size\+\_\+t \hyperlink{namespacejlettvin_a5c480560edc7a71c9f5ae6dad14e6fec}{codepoint\+\_\+t}\label{namespacejlettvin_a5c480560edc7a71c9f5ae6dad14e6fec}

\begin{DoxyCompactList}\small\item\em clear type of codepoint \end{DoxyCompactList}\item 
\hypertarget{namespacejlettvin_ac925326f2732a65f4e3caaea182401a9}{}typedef size\+\_\+t \hyperlink{namespacejlettvin_ac925326f2732a65f4e3caaea182401a9}{target\+\_\+t}\label{namespacejlettvin_ac925326f2732a65f4e3caaea182401a9}

\begin{DoxyCompactList}\small\item\em clear type of result \end{DoxyCompactList}\item 
\hypertarget{namespacejlettvin_af3d2e8320ecb86b316e2069e9de6e8f2}{}typedef size\+\_\+t \hyperlink{namespacejlettvin_af3d2e8320ecb86b316e2069e9de6e8f2}{either\+\_\+t}\label{namespacejlettvin_af3d2e8320ecb86b316e2069e9de6e8f2}

\begin{DoxyCompactList}\small\item\em ambiguous type \end{DoxyCompactList}\item 
\hypertarget{namespacejlettvin_a7133ba660d288e5f368d7285843739c8}{}typedef vector$<$ \hyperlink{namespacejlettvin_af3d2e8320ecb86b316e2069e9de6e8f2}{either\+\_\+t} $>$ \hyperlink{namespacejlettvin_a7133ba660d288e5f368d7285843739c8}{subtable\+\_\+t}\label{namespacejlettvin_a7133ba660d288e5f368d7285843739c8}

\begin{DoxyCompactList}\small\item\em type of table entry \end{DoxyCompactList}\item 
\hypertarget{namespacejlettvin_a7791a7f100e442c5b74a901442cd3197}{}typedef vector$<$ \hyperlink{namespacejlettvin_a7133ba660d288e5f368d7285843739c8}{subtable\+\_\+t} $>$ \hyperlink{namespacejlettvin_a7791a7f100e442c5b74a901442cd3197}{T\+\_\+type}\label{namespacejlettvin_a7791a7f100e442c5b74a901442cd3197}

\begin{DoxyCompactList}\small\item\em type of table \end{DoxyCompactList}\item 
\hypertarget{namespacejlettvin_a37ff8ef881a4ed6efce44bac38621732}{}typedef map$<$ \hyperlink{namespacejlettvin_a5c480560edc7a71c9f5ae6dad14e6fec}{codepoint\+\_\+t}, \hyperlink{namespacejlettvin_ac925326f2732a65f4e3caaea182401a9}{target\+\_\+t} $>$ \hyperlink{namespacejlettvin_a37ff8ef881a4ed6efce44bac38621732}{M\+\_\+type}\label{namespacejlettvin_a37ff8ef881a4ed6efce44bac38621732}

\begin{DoxyCompactList}\small\item\em type of dict \end{DoxyCompactList}\item 
\hypertarget{namespacejlettvin_a717af5c4fa2045ec8271403a711500be}{}typedef T\+\_\+type\+::const\+\_\+iterator \hyperlink{namespacejlettvin_a717af5c4fa2045ec8271403a711500be}{T\+\_\+iter}\label{namespacejlettvin_a717af5c4fa2045ec8271403a711500be}

\begin{DoxyCompactList}\small\item\em table iterator \end{DoxyCompactList}\item 
\hypertarget{namespacejlettvin_adb899a2c00ed7361dbc22a0bc907f88c}{}typedef M\+\_\+type\+::const\+\_\+iterator \hyperlink{namespacejlettvin_adb899a2c00ed7361dbc22a0bc907f88c}{M\+\_\+iter}\label{namespacejlettvin_adb899a2c00ed7361dbc22a0bc907f88c}

\begin{DoxyCompactList}\small\item\em dict iterator \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename B , typename L $>$ }\\B \& \hyperlink{namespacejlettvin_a22a95d44fbce8da6d460dbad5bddb41a}{endless} (L \&a32, const size\+\_\+t off)
\item 
\hypertarget{namespacejlettvin_ae776f6a66f5697c5cb2afb2c6efdbfd7}{}{\footnotesize template$<$typename T1 $>$ }\\ostream \& \hyperlink{namespacejlettvin_ae776f6a66f5697c5cb2afb2c6efdbfd7}{operator$<$$<$} (ostream \&o, const vector$<$ T1 $>$ \&v)\label{namespacejlettvin_ae776f6a66f5697c5cb2afb2c6efdbfd7}

\begin{DoxyCompactList}\small\item\em enable use of cout $<$$<$ T $<$$<$ std\+::endl; \end{DoxyCompactList}\item 
void \hyperlink{namespacejlettvin_ab09212af893947acc85d4e6138b60ba2}{char32\+\_\+t\+\_\+to\+\_\+\+U\+T\+F8} (const char32\+\_\+t source, \hyperlink{namespacejlettvin_a7c7cf84f4fd67858c46a1077ed2e3ad4}{ubyte\+\_\+t} target\mbox{[}5\mbox{]})
\item 
char32\+\_\+t \hyperlink{namespacejlettvin_ae1f5a0c22c3f8c9eecb88f086bcbcc30}{U\+T\+F8\+\_\+to\+\_\+char32\+\_\+t} (const \hyperlink{namespacejlettvin_a7c7cf84f4fd67858c46a1077ed2e3ad4}{ubyte\+\_\+t} $\ast$buf, size\+\_\+t \&head, const size\+\_\+t tail)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
$<$ cpplint complains even though existing file is included 

\subsection{Function Documentation}
\hypertarget{namespacejlettvin_ab09212af893947acc85d4e6138b60ba2}{}\index{jlettvin@{jlettvin}!char32\+\_\+t\+\_\+to\+\_\+\+U\+T\+F8@{char32\+\_\+t\+\_\+to\+\_\+\+U\+T\+F8}}
\index{char32\+\_\+t\+\_\+to\+\_\+\+U\+T\+F8@{char32\+\_\+t\+\_\+to\+\_\+\+U\+T\+F8}!jlettvin@{jlettvin}}
\subsubsection[{char32\+\_\+t\+\_\+to\+\_\+\+U\+T\+F8(const char32\+\_\+t source, ubyte\+\_\+t target[5])}]{\setlength{\rightskip}{0pt plus 5cm}void jlettvin\+::char32\+\_\+t\+\_\+to\+\_\+\+U\+T\+F8 (
\begin{DoxyParamCaption}
\item[{const char32\+\_\+t}]{source, }
\item[{{\bf ubyte\+\_\+t}}]{target\mbox{[}5\mbox{]}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespacejlettvin_ab09212af893947acc85d4e6138b60ba2}
char32\+\_\+t\+\_\+to\+\_\+\+U\+T\+F8 converts internal 32 bit codepoints to U\+T\+F8.


\begin{DoxyParams}{Parameters}
{\em source} & is a 32 bit codepoint \\
\hline
{\em target} & is a 5 unsigned byte buffer from the caller.\\
\hline
\end{DoxyParams}
The codepoint is converted to U\+T\+F8 with trailing N\+U\+L bytes such that it is immediately ready for output via std\+::cout.

Branch points are avoided. Maximum cost is 23 Intel opcodes. \hypertarget{namespacejlettvin_a22a95d44fbce8da6d460dbad5bddb41a}{}\index{jlettvin@{jlettvin}!endless@{endless}}
\index{endless@{endless}!jlettvin@{jlettvin}}
\subsubsection[{endless(\+L \&a32, const size\+\_\+t off)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename B , typename L $>$ B\& jlettvin\+::endless (
\begin{DoxyParamCaption}
\item[{L \&}]{a32, }
\item[{const size\+\_\+t}]{off}
\end{DoxyParamCaption}
)}\label{namespacejlettvin_a22a95d44fbce8da6d460dbad5bddb41a}
endless is a template function for extracting bytes from 32 bit longs.


\begin{DoxyParams}{Parameters}
{\em a32} & a 32 bit wide unsigned int value from which to extract bytes. \\
\hline
{\em off} & an index (between 0 and 3) byte position within a32.\\
\hline
\end{DoxyParams}
endless(a\+\_\+32\+\_\+bit\+\_\+value, unsigned\+\_\+between\+\_\+0\+\_\+and\+\_\+3) returns a reference to the same-\/valued byte invariant of endianness. These indices address the byte containing the same value in 32 bits regardless of machine endianness because the endian index setter has the index values jammed together such that they split out into the correct indices. The extra cost is one instruction for one extra indirection.

size\+\_\+t funny = 0x76543210; cout $<$$<$ hex $<$$<$ endless(funny, 0); // outputs 10 on all machines. cout $<$$<$ hex $<$$<$ endless(funny, 3); // outputs 76 on all machines. endless(joy, 3) = 0x98; // always replaces 76 with 98.\hypertarget{namespacejlettvin_ae1f5a0c22c3f8c9eecb88f086bcbcc30}{}\index{jlettvin@{jlettvin}!U\+T\+F8\+\_\+to\+\_\+char32\+\_\+t@{U\+T\+F8\+\_\+to\+\_\+char32\+\_\+t}}
\index{U\+T\+F8\+\_\+to\+\_\+char32\+\_\+t@{U\+T\+F8\+\_\+to\+\_\+char32\+\_\+t}!jlettvin@{jlettvin}}
\subsubsection[{U\+T\+F8\+\_\+to\+\_\+char32\+\_\+t(const ubyte\+\_\+t $\ast$buf, size\+\_\+t \&head, const size\+\_\+t tail)}]{\setlength{\rightskip}{0pt plus 5cm}char32\+\_\+t jlettvin\+::\+U\+T\+F8\+\_\+to\+\_\+char32\+\_\+t (
\begin{DoxyParamCaption}
\item[{const {\bf ubyte\+\_\+t} $\ast$}]{buf, }
\item[{size\+\_\+t \&}]{head, }
\item[{const size\+\_\+t}]{tail}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespacejlettvin_ae1f5a0c22c3f8c9eecb88f086bcbcc30}
U\+T\+F8\+\_\+to\+\_\+32 converts U\+T\+F8 to internal 32 bit codepoint value.


\begin{DoxyParams}{Parameters}
{\em buf} & is a buffer full of U\+T\+F8 unsigned bytes. \\
\hline
{\em head} & is the index where ingest begins or continues (variable). \\
\hline
{\em tail} & is the index past the last byte in the buffer.\\
\hline
\end{DoxyParams}
This function is designed to make conversion efficient. It uses the gnu c++ compiler support for computed goto to eliminate the need for branch points.

Review of a least and most costly execution in opcode counts. No stack frame is generated or discarded (inline). The caller provides room in its stack frame for this function. Least\+: 2 opcodes\+: compare head to tail, goto err; 2 opcodes\+: cast byte 0 to 32 bit return (essentially a goto) Most\+: 2 opcodes\+: compare head to tail goto ingest 6 opcodes\+: dereference byte, increment, shift, mask, cast, goto enough 6 opcodes\+: dereference byte, increment, shift, mask, cast, goto a1e 6 opcodes\+: dereference byte, increment, shift, mask, cast, goto db 6 opcodes\+: dereference byte, increment, shift, mask, cast, goto dc 6 opcodes\+: dereference byte, increment, shift, mask, cast, goto dd 2 opcodes\+: update head, return 34 total opcodes

T\+O\+D\+O fix so it works 