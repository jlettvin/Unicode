This library contains modules for efficient lexical operations on Unicode strings to support simple generation of D\+S\+L (Domain Specific Languages). A dynamic library is generated. Unit tests exercise most of the functionality. Mostly, the D\+R\+Y principle has been followed. More work is needed in two directions\+:
\begin{DoxyItemize}
\item More unit tests (including failure modes)
\item T\+D\+D Implement \hyperlink{class_tree}{Tree} functionality.
\end{DoxyItemize}


\begin{DoxyCode}
1 html                doxygen output directory
2 latex               doxygen output directory
3 .gitignore          patterns of intermediate files not to be stored on github
4 Doxyfile            control for doxygen production
5 LICENSE             (GPLv3)
6 LinkDefs.h          common root of doxygen
7 Makefile            control for production of this resource
8 Node.cpp            O(1) dictionary translating Codepoints to Tablenumbers
9 Node.h              interface
10 README.md           this file
11 Tree.cpp            O(N) dictionary translating u32strings to Canonical Lists
12 Tree.h              interface
13 Unicode.h           primitives (including inline UTF8/codepoint translations)
14 haiku.utf8.cpp      copy of what test\_Unicode is to produce (for comparison)
15 haiku.utf8.txt      102 language to test UTF8/codepoint conversions
16 test\_Node.cpp       unit tests
17 test\_Tree.cpp       unit tests
18 test\_Unicode.cpp    unit tests
\end{DoxyCode}


\subsection*{Requirements\+:}


\begin{DoxyItemize}
\item g++ (gnu c++ compiler) supporting the -\/std=c++11 flag
\item cpplint
\item valgrind
\item doxygen
\end{DoxyItemize}

\subsection*{Build\+:}


\begin{DoxyItemize}
\item make clean; clear; make
\end{DoxyItemize}

\subsection*{Theory\+:}

Dictionary lookup typically incurs a cost of calculating the hash followed by disambiguating the hash bucket. Both of these calculations can be expensive. The cost is fixed for hash tables with no collisions.

\hyperlink{class_node}{Node} and \hyperlink{class_tree}{Tree} are alternative algorithms for guaranteeing low fixed cost dictionary operations on simple Unicode codepoints (\hyperlink{class_node}{Node}) and simple Unicode codepoint strings (\hyperlink{class_tree}{Tree}).

\subsubsection*{Observations supporting the \hyperlink{class_node}{Node} implementation\+:}

Codepoints have 21 significant bits. Observe letter B converted to indices. 
\begin{DoxyCode}
1 B
2 0042                          hexadecimal
3 000000000000001000010         binary
4 000 000 000 000 001 000 010   7 groups of 3
5 a=0 b=0 c=0 d=0 e=1 f=0 g=2   position labels and indices
\end{DoxyCode}


Lookup is performed by multiple table dereferences to get new indices. The code for getting an association for a codepoint is\+: 
\begin{DoxyCode}
1 ((codepoint>>(n*3))&0xf) where a uses n==0, b uses n==1, etc...
2 lookup(codepoint) \{ return T[T[T[T[T[T[T[1][g]][f]][e]][d]][c]][b]][a] \}
\end{DoxyCode}

\begin{DoxyItemize}
\item 7 multiplies \# Can be eliminated by manifest constants
\item 7 shifts
\item 7 masks
\item 8 table dereferences
\item 29 total machine code operations in original i\+A\+P\+X86 8088 instructions
\item operation count may be less for more recent processors
\item memory consumption per layer is 32 bytes
\end{DoxyItemize}

Consider all the values to be hexadecimal. The initial table index is 1 because index 0 is used to flag errors. Suppose we want to associate the codepoint for letter \textquotesingle{}B\textquotesingle{} with its codepoint. In other words, this lookup will be the identity function lookup(42) = 42. We will restrict the hex representation to 16 bits for visual ease. Keep in mind that the full width is 21. We start by building a table T with the following contents\+: 
\begin{DoxyCode}
1 B
2 0042
3 000000000000001000011
4 000 000 000 000 001 000 010
5 a=0 b=0 c=0 d=0 e=1 f=0 g=2
6 T = [
7  [0000 0000 0000 0000 0000 0000 0000 0000]  # <- error layer (all zeros always)
8  [0002 0000 0000 0000 0000 0000 0000 0000]  # <- starting index for lookup
9  [0003 0000 0000 0000 0000 0000 0000 0000]
10  [0004 0000 0000 0000 0000 0000 0000 0000]
11  [0005 0000 0000 0000 0000 0000 0000 0000]
12  [0000 0006 0000 0000 0000 0000 0000 0000]
13  [0007 0000 0000 0000 0000 0000 0000 0000]
14  [0000 0000 0042 0000 0000 0000 0000 0000]  # <- layer containing association
15 ]
\end{DoxyCode}


Illustration of sequential dereferencing. 
\begin{DoxyCode}
1 T[1][a] yields 2 then
2 T[2][b] yields 3 then
3 T[3][c] yields 4 then
4 T[4][d] yields 5 then
5 T[5][e] yields 6 then
6 T[6][f] yields 7 then
7 T[7][g] yields 42  # The association
\end{DoxyCode}


If we want to add an association for \textquotesingle{}C\textquotesingle{} the table will look like this\+: 
\begin{DoxyCode}
1 C
2 0043
3 000000000000001000011
4 000 000 000 000 001 000 011
5 a=0 b=0 c=0 d=0 e=1 f=0 g=3
6 T = [
7  [0000 0000 0000 0000 0000 0000 0000 0000]
8  [0002 0000 0000 0000 0000 0000 0000 0000]
9  [0003 0000 0000 0000 0000 0000 0000 0000]
10  [0004 0000 0000 0000 0000 0000 0000 0000]
11  [0005 0000 0000 0000 0000 0000 0000 0000]
12  [0000 0006 0000 0000 0000 0000 0000 0000]
13  [0007 0000 0000 0000 0000 0000 0000 0000]
14  [0000 0000 0042 0043 0000 0000 0000 0000] # <- table 8 has 0043 at offset 3
15 ]
\end{DoxyCode}
 Note how no layers were added to support \textquotesingle{}C\textquotesingle{}.

If we want to add an association for \textquotesingle{}L\textquotesingle{} the table will look like this. 
\begin{DoxyCode}
1 L
2 004C
3 000000000000001001100
4 000 000 000 000 001 001 100
5 a=0 b=0 c=0 d=0 e=1 f=1 g=4
6 T = [
7  [0000 0000 0000 0000 0000 0000 0000 0000]
8  [0002 0000 0000 0000 0000 0000 0000 0000]
9  [0003 0000 0000 0000 0000 0000 0000 0000]
10  [0004 0000 0000 0000 0000 0000 0000 0000]
11  [0005 0000 0000 0000 0000 0000 0000 0000]
12  [0000 0006 0000 0000 0000 0000 0000 0000]
13  [0007 0008 0000 0000 0000 0000 0000 0000] # <- see the addition of table 8
14  [0000 0000 0042 0043 0000 0000 0000 0000]
15  [0000 0000 0000 0000 004C 0000 0000 0000] # <- table 8 has 004C at offset 4
16 ]
\end{DoxyCode}


Now, let\textquotesingle{}s add the Chinese character for mountain U+5\+C71 
\begin{DoxyCode}
1 å±±
2 5C71
3 000000101110001110001 
4 000 000 101 110 001 110 001
5 a=0 b=0 c=5 d=6 e=1 f=6 g=1
6 T = [
7  [0000 0000 0000 0000 0000 0000 0000 0000]
8  [0002 0000 0000 0000 0000 0000 0000 0000]
9  [0003 0000 0000 0000 0000 0000 0000 0000]
10  [0004 0000 0000 0000 0000 0009 0000 0000] # <- see the addition of table 9
11  [0005 0000 0000 0000 0000 0000 0000 0000]
12  [0000 0006 0000 0000 0000 0000 0000 0000]
13  [0007 0008 0000 0000 0000 0000 0000 0000]
14  [0000 0000 0042 0043 0000 0000 0000 0000]
15  [0000 0000 0000 0000 004C 0000 0000 0000]
16  [0000 0000 0000 0000 0000 0000 000A 0000] # <- see the addition of table A
17  [0000 000B 0000 0000 0000 0000 0000 0000] # <- see the addition of table B
18  [0000 0000 0000 0000 0000 0000 000C 0000] # <- see the addition of table C
19  [0000 000D 0000 0000 0000 0000 0000 0000] # <- see the addition of table D
20  [0000 5C71 0000 0000 0000 0000 0000 0000] # <- table D has 5C71 at offset 1
21 ]
\end{DoxyCode}


Illustration of sequential dereferencing for that Chinese character. 
\begin{DoxyCode}
1 T[1][a] yields 2 then
2 T[2][b] yields 3 then
3 T[3][c] yields 9 then
4 T[4][d] yields A then
5 T[5][e] yields B then
6 T[6][f] yields C then
7 T[7][g] yields 5C71  # The association
\end{DoxyCode}


Using 3 groups of 7, the operation count drops to 17 and the memory consumption per layer is 512 bytes.

7 groups of 3 may look a bit inefficient with space, but 3 groups of 7 would be worse. The total consumed here by 7 groups of 3 is 14 $\ast$ 32 = 448 butes. For 3 groups of 7 this would be 6 $\ast$ 512 = 3017 bytes. 7 groups of 3 increases the calculation time by 7/3 or 2.\+3333... We choose to trade speed for space. These representations can be stored and recovered from disk.

Summary\+:
\begin{DoxyItemize}
\item Codepoints are intrinsically 21 bits.
\item 21 is the product 3 $\ast$ 7.
\item 3 groups of 7 bits or 7 groups of 3 bits will fit a codepoint perfectly.
\item a 32 bit internal codepoint or index occupies 4 bytes.
\item 3 bits supports 8 indices while 7 bits supports 128 indices.
\item 7 groups of 3 is used because the table layer size is small (32 bytes).
\item The initial association costs 8 $\ast$ 32 = 256 bytes.
\item Subsequent associations in-\/layer cost 0 additional bytes.
\item Subsequent associations out-\/of-\/layer cost at least one final layer each.
\item Worst case cost (i.\+e. 0x10\+F\+F\+F) costs 6 additional layers.
\end{DoxyItemize}

\subsubsection*{Special Notes\+:}

0x10\+F\+F\+F\+F is used as a sentinel in the code as the highest legal codepoint. This is permitted for two reasons, it enables detection of some errors, and it is documented to never be transmitted and is declared a nonchar.

\subsection*{\hyperlink{_unicode_8h_source}{Unicode.\+h}\+: Shared resources}


\begin{DoxyItemize}
\item Output function for tables
\item Input conversion from unsigned U\+T\+F8 bytes char32\+\_\+t internal codepoints.
\item Output conversion from char32\+\_\+t internal codepoints to unsigned U\+T\+F8 bytes.
\end{DoxyItemize}

This implementation eliminates function calls and branch points. Data flows through a table of computed gotos for translations both ways.

\subsection*{\hyperlink{class_node}{Node}\+: an O(1) state transition mechanism}

\hyperlink{class_node}{Node} acts as an O(1) dictionary to translate Unicode Codepoints or Unicode Codepoint classifications into table numbers. This enables rapid state machine operations.

\subsection*{\hyperlink{class_tree}{Tree}\+: an O(\+N) token lookup mechanism}

\hyperlink{class_tree}{Tree} acts as an O(\+N) dictionary to identify and/or canonicalize valid Unicode tokens. It can be used to recognize keywords. It can also be used to identify tokens that are absent from the dictionary. 