#!/usr/bin/env python
# -*- coding: utf8 -*-

"""UniGrammar.py
This class generates grammar files used to identify Unicode codepoint class.

TODO: automate more, manifest constant less.
"""

__module__     = "UniGrammar.py"
__author__     = "Jonathan D. Lettvin"
__copyright__  = "\
Copyright(C) 2016 Jonathan D. Lettvin, All Rights Reserved"
__credits__    = ["Jonathan D. Lettvin"]
__license__    = "GPLv3"
__version__    = "0.0.1"
__maintainer__ = "Jonathan D. Lettvin"
__email__      = "jlettvin@gmail.com"
__contact__    = "jlettvin@gmail.com"
__status__     = "Demonstration"
__date__       = "20161111"

from datetime import (datetime)
import re

from UniClass import (UniClass)


class UniGrammar(dict):
    "Means of production for antlr4 grammars"

    def __init__(self):
        "Initialize grammars for antlr4"
        self.uniclass = UniClass()
        self.labelled = {label: [] for label in UniClass.label}
        that = None
        codepoint, top = 0x0, 0x110000
        for codepoint in xrange(top):
            this = UniClass.classify(codepoint)
            if that != this:
                if that is not None:
                    self.labelled[that][-1].append(codepoint)
                self.labelled[this].append([codepoint])
                that = this
        that = UniClass.classify(top - 1)
        self.labelled[that][-1].append(codepoint)

        with open("local/PropertyValueAliases.txt") as source:
            find = 'gc ; '
            self.prop = {'__': 'Error'}
            for line in source.readlines():
                if line.startswith(find):
                    part = line.split(';')
                    self.prop[part[1].strip()] = part[2].strip()

        self.identify = [0] * top
        with open("local/Blocks.txt") as source:
            pattern = re.compile(r"([0-9A-F]{4,6})\.\.([0-9A-F]{4,6}); (.*)")
            self.block = {}

            for line in source:
                found = pattern.match(line)
                if found:
                    self.block[found.group(3).replace(' ', '_')] = [
                        found.group(i) for i in [1, 2]
                    ]
        self.noblock = '(Absent from Blocks.txt)'
        self.blockname = [self.noblock] + sorted(self.block.keys())
        for i, name in enumerate(self.blockname):
            self.blockname[i] = name
        for i, name in enumerate(self.blockname):
            if isinstance(name, str) and name is not self.noblock:
                endpoint = self.block[name]
                A, B = (int(s, 0x10) for s in endpoint)
                for codepoint in xrange(A, B):
                    self.identify[codepoint] = i

    def antlr4(self, **kw):
        "Generate the grammar file according to the kw parameters"
        width = kw.get('width', 21)
        prefix = kw.get('prefix', 'CLASSIFY_')
        emit = """/** classify%d.g4
Automatically generated Unicode 9.0.0 codepoint classification grammar.
Generated by "UniGrammar.py".

Author: Jonathan D. Lettvin (jlettvin@gmail.com)
Date:   %s

Legal:  Copyright(c) Jonathan D. Lettvin, All Rights Reserved
License:GPL 3.0

Rules are generated by extracting from:

    local/UnicodeData.txt
    local/PropList.txt

acquired from

    site: ftp://ftp.unicode.org/Public/

 */

 grammar classify;

""" % (width, datetime.now().isoformat())

        final = '\n'.join(["%s%s\n" % (prefix, group) for group in [
            """C :
       %sCc
     | %sCf
     | %sCo
     | %sCs  // from local/PropertyValueAliases.txt
;""" % tuple([prefix] * 4),

            """LC :
       %sLl
     | %sLt
     | %sLu  // from local/PropertyValueAliases.txt
;""" % tuple([prefix] * 3),

            """M :
       %sMc
     | %sMe
     | %sMn  // from local/PropertyValueAliases.txt
;""" % tuple([prefix] * 3),

            """L :
       %sLl
     | %sLm
     | %sLo
     | %sLt
     | %sLu  // from local/PropertyValueAliases.txt
;""" % tuple([prefix] * 5),

            """N :
       %sNd
     | %sNl
     | %sNo  // from local/PropertyValueAliases.txt
;""" % tuple([prefix] * 3),

            """P :
       %sPc
     | %sPd
     | %sPe
     | %sPf
     | %sPi
     | %sPo
     | %sPs  // from local/PropertyValueAliases.txt
;""" % tuple([prefix] * 7),

            """S :
       %sSc
     | %sSk
     | %sSm
     | %sSo  // from local/PropertyValueAliases.txt
;""" % tuple([prefix] * 4),

            """Z :
       %sZl
     | %sZp
     | %sZs  // from local/PropertyValueAliases.txt
;""" % tuple([prefix] * 3)
        ]])

        final += """\n\n/* Unicode codepoint classification */

%sWS : %sZ +                  // hand-written rule
;

%sID0 : %sL | '_'             // hand-written rule
;

%sID1 : %sID0 | %sN    // hand-written rule
;

ID : %sID0 %sID1 *            // hand-written rule
;
""" % tuple([prefix] * 9)

        emit += "codepoint:\n      "
        emit += '\n    | '.join([
            "%s%s  // %s" % (prefix, label, self.prop[label])
            for label in UniClass.label])
        emit += "\n;\n"

        full = int(width == 21)
        digits = [4, 6][full]
        space1 = ' ' * [4, 2][full]
        space2 = ' ' * [4, 2][full]
        top = [0xFFFF, 0x10FFFF][full]
        args1 = (digits, space1)
        args2 = (digits, digits, space2)
        fmt = [
            "    %%s '\\u%%0%dx'             %s// %%s\n" % args1,
            "    %%s '\\u%%0%dx'..'\\u%%0%dx'   %s// %%s\n" % args2
        ]

        for label in UniClass.label:
            emit += "\n%s%s:\n" % (prefix, label)
            pipe = ' '
            for A, B in self.labelled[label]:
                if A > top or B > top:
                    continue
                runlength = B - A
                identity = self.blockname[self.identify[A]]
                if runlength == 1:
                    emit += fmt[0] % (pipe, A,    identity)
                else:
                    emit += fmt[1] % (pipe, A, B, identity)
                pipe = '|'
            emit += ';\n'

        emit += final

        return emit


if __name__ == "__main__":

    unigrammar = UniGrammar()
    with open("classify16.g4", 'w+') as grammar:
        grammar.write(unigrammar.antlr4(width=16))
    with open("classify21.g4", 'w+') as grammar:
        grammar.write(unigrammar.antlr4(width=21))
